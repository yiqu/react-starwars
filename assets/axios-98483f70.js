import{R as At,r as w,aH as Ht}from"./index-2601b20a.js";import{a as Vt}from"./index-2dd56a59.js";const N=new WeakMap,Ot={},M=()=>{},b=M(),it=Object,u=t=>t===b,L=t=>typeof t=="function",W=(t,n)=>({...t,...n}),Rt="undefined",nt=typeof window!=Rt,ft=typeof document!=Rt,Gt=()=>nt&&typeof window.requestAnimationFrame!=Rt,It=(t,n)=>{const e=N.get(t);return[()=>t.get(n)||Ot,s=>{const o=t.get(n);e[5](n,W(o,s),o||Ot)},e[6]]},et=new WeakMap;let zt=0;const Y=t=>{const n=typeof t,e=t&&t.constructor,s=e==Date;let o,i;if(it(t)===t&&!s&&e!=RegExp){if(o=et.get(t),o)return o;if(o=++zt+"~",et.set(t,o),e==Array){for(o="@",i=0;i<t.length;i++)o+=Y(t[i])+",";et.set(t,o)}if(e==it){o="#";const c=it.keys(t).sort();for(;!u(i=c.pop());)u(t[i])||(o+=i+":"+Y(t[i])+",");et.set(t,o)}}else o=s?t.toJSON():n=="symbol"?t.toString():n=="string"?JSON.stringify(t):""+t;return o};let dt=!0;const Bt=()=>dt,[Et,ht]=nt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[M,M],Jt=()=>{const t=ft&&document.visibilityState;return u(t)||t!=="hidden"},Kt=t=>(ft&&document.addEventListener("visibilitychange",t),Et("focus",t),()=>{ft&&document.removeEventListener("visibilitychange",t),ht("focus",t)}),Yt=t=>{const n=()=>{dt=!0,t()},e=()=>{dt=!1};return Et("online",n),Et("offline",e),()=>{ht("online",n),ht("offline",e)}},$t={isOnline:Bt,isVisible:Jt},Qt={initFocus:Kt,initReconnect:Yt},bt=!At.useId,$=!nt||"Deno"in window,Xt=t=>Gt()?window.requestAnimationFrame(t):setTimeout(t,1),at=$?w.useEffect:w.useLayoutEffect,ct=typeof navigator<"u"&&navigator.connection,vt=!$&&ct&&(["slow-2g","2g"].includes(ct.effectiveType)||ct.saveData),mt=t=>{if(L(t))try{t=t()}catch{t=""}const n=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Y(t):"",[t,n]};let Zt=0;const pt=()=>++Zt,Nt=0,Lt=1,Ft=2;var ut={__proto__:null,FOCUS_EVENT:Nt,RECONNECT_EVENT:Lt,MUTATE_EVENT:Ft};async function xt(...t){const[n,e,s,o]=t,i=W({populateCache:!0,throwOnError:!0},typeof o=="boolean"?{revalidate:o}:o||{});let c=i.populateCache;const E=i.rollbackOnError;let d=i.optimisticData;const D=i.revalidate!==!1,m=y=>typeof E=="function"?E(y):E!==!1,_=i.throwOnError;if(L(e)){const y=e,l=[],r=n.keys();for(let O=r.next();!O.done;O=r.next()){const A=O.value;!A.startsWith("$inf$")&&y(n.get(A)._k)&&l.push(A)}return Promise.all(l.map(S))}return S(e);async function S(y){const[l]=mt(y);if(!l)return;const[r,O]=It(n,l),[A,V,q]=N.get(n),U=A[l],j=()=>D&&(delete q[l],U&&U[0])?U[0](Ft).then(()=>r().data):r().data;if(t.length<3)return j();let a=s,C;const F=pt();V[l]=[F,0];const H=!u(d),Q=r(),k=Q.data,X=Q._c,x=u(X)?k:X;if(H&&(d=L(d)?d(x):d,O({data:d,_c:x})),L(a))try{a=a(x)}catch(v){C=v}if(a&&L(a.then))if(a=await a.catch(v=>{C=v}),F!==V[l][0]){if(C)throw C;return a}else C&&H&&m(C)&&(c=!0,a=x,O({data:a,_c:b}));c&&(C||(L(c)&&(a=c(a,x)),O({data:a,_c:b}))),V[l][1]=pt();const Z=await j();if(O({_c:b}),C){if(_)throw C;return}return c?Z:a}}const Dt=(t,n)=>{for(const e in t)t[e][0]&&t[e][0](n)},te=(t,n)=>{if(!N.has(t)){const e=W(Qt,n),s={},o=xt.bind(b,t);let i=M;const c={},E=(m,_)=>{const S=c[m]||[];return c[m]=S,S.push(_),()=>S.splice(S.indexOf(_),1)},d=(m,_,S)=>{t.set(m,_);const y=c[m];if(y)for(let l=y.length;l--;)y[l](S,_)},D=()=>{if(!N.has(t)&&(N.set(t,[s,{},{},{},o,d,E]),!$)){const m=e.initFocus(setTimeout.bind(b,Dt.bind(b,s,Nt))),_=e.initReconnect(setTimeout.bind(b,Dt.bind(b,s,Lt)));i=()=>{m&&m(),_&&_(),N.delete(t)}}};return D(),[t,o,D,i]}return[t,N.get(t)[4]]},ee=(t,n,e,s,o)=>{const i=e.errorRetryCount,c=o.retryCount,E=~~((Math.random()+.5)*(1<<(c<8?c:8)))*e.errorRetryInterval;!u(i)&&c>i||setTimeout(s,E,o)},ne=(t,n)=>Y(t)==Y(n),[Mt,se]=te(new Map),oe=W({onLoadingSlow:M,onSuccess:M,onError:M,onErrorRetry:ee,onDiscarded:M,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:vt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:vt?5e3:3e3,compare:ne,isPaused:()=>!1,cache:Mt,mutate:se,fallback:{}},$t),re=(t,n)=>{const e=W(t,n);if(n){const{use:s,fallback:o}=t,{use:i,fallback:c}=n;s&&i&&(e.use=s.concat(i)),o&&c&&(e.fallback=W(o,c))}return e},ie=w.createContext({}),Wt=nt&&window.__SWR_DEVTOOLS_USE__,ae=Wt?window.__SWR_DEVTOOLS_USE__:[],ce=()=>{Wt&&(window.__SWR_DEVTOOLS_REACT__=At)},Ut=t=>L(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],ue=()=>W(oe,w.useContext(ie)),le=t=>(n,e,s)=>t(n,e&&((...i)=>{const c=mt(n)[0],[,,,E]=N.get(Mt),d=E[c];return d?(delete E[c],d):e(...i)}),s),fe=ae.concat(le),de=t=>function(...e){const s=ue(),[o,i,c]=Ut(e),E=re(s,c);let d=t;const{use:D}=E,m=(D||[]).concat(fe);for(let _=m.length;_--;)d=m[_](d);return d(o,i||E.fetcher||null,E)},Ee=(t,n,e)=>{const s=n[t]||(n[t]=[]);return s.push(e),()=>{const o=s.indexOf(e);o>=0&&(s[o]=s[s.length-1],s.pop())}},me=(t,n)=>(...e)=>{const[s,o,i]=Ut(e),c=(i.use||[]).concat(n);return t(s,o,{...i,use:c})};ce();const lt={dedupe:!0},he=(t,n,e)=>{const{cache:s,compare:o,suspense:i,fallbackData:c,revalidateOnMount:E,refreshInterval:d,refreshWhenHidden:D,refreshWhenOffline:m,keepPreviousData:_}=e,[S,y,l]=N.get(s),[r,O]=mt(t),A=w.useRef(!1),V=w.useRef(!1),q=w.useRef(r),U=w.useRef(n),j=w.useRef(e),a=()=>j.current,C=()=>a().isVisible()&&a().isOnline(),[F,H,Q]=It(s,r),k=w.useRef({}).current,X=u(c)?e.fallback[r]:c,x=(f,p)=>{let h=!0;for(const R in k){const T=R;o(p[T],f[T])||T==="data"&&u(f[T])&&o(p[T],ot)||(h=!1)}return h},Z=w.useMemo(()=>{const f=(()=>!r||!n?!1:u(E)?!(a().isPaused()||i):E)(),p=()=>{const R=F(),T=W(R);return delete T._k,f?{isValidating:!0,isLoading:!0,...T}:T};let h=p();return()=>{const R=p();return x(R,h)?h:h=R}},[s,r]),v=Ht.useSyncExternalStore(w.useCallback(f=>Q(r,(p,h)=>{x(p,h)||f()}),[s,r]),Z,Z),Tt=!A.current,G=v.data,P=u(G)?X:G,st=v.error,wt=w.useRef(P),ot=_?u(G)?wt.current:G:P,_t=(()=>Tt&&!u(E)?E:a().isPaused()?!1:i?u(P)?!1:e.revalidateIfStale:u(P)||e.revalidateIfStale)(),Ct=!!(r&&n&&Tt&&_t),Pt=u(v.isValidating)?Ct:v.isValidating,qt=u(v.isLoading)?Ct:v.isLoading,B=w.useCallback(async f=>{const p=U.current;if(!r||!p||V.current||a().isPaused())return!1;let h,R,T=!0;const J=f||{},z=!l[r]||!J.dedupe,K=()=>bt?!V.current&&r===q.current&&A.current:r===q.current,tt={isValidating:!1,isLoading:!1},gt=()=>{H(tt)},St=()=>{const g=l[r];g&&g[1]===R&&delete l[r]},yt={isValidating:!0};u(F().data)&&(yt.isLoading=!0);try{if(z&&(H(yt),e.loadingTimeout&&u(F().data)&&setTimeout(()=>{T&&K()&&a().onLoadingSlow(r,e)},e.loadingTimeout),l[r]=[p(O),pt()]),[h,R]=l[r],h=await h,z&&setTimeout(St,e.dedupingInterval),!l[r]||l[r][1]!==R)return z&&K()&&a().onDiscarded(r),!1;tt.error=b;const g=y[r];if(!u(g)&&(R<=g[0]||R<=g[1]||g[1]===0))return gt(),z&&K()&&a().onDiscarded(r),!1;const I=F().data;tt.data=o(I,h)?I:h,z&&K()&&a().onSuccess(h,r,e)}catch(g){St();const I=a(),{shouldRetryOnError:rt}=I;I.isPaused()||(tt.error=g,z&&K()&&(I.onError(g,r,I),(rt===!0||L(rt)&&rt(g))&&C()&&I.onErrorRetry(g,r,I,B,{retryCount:(J.retryCount||0)+1,dedupe:!0})))}return T=!1,gt(),!0},[r,s]),jt=w.useCallback((...f)=>xt(s,q.current,...f),[]);if(at(()=>{U.current=n,j.current=e,u(G)||(wt.current=G)}),at(()=>{if(!r)return;const f=B.bind(b,lt);let p=0;const R=Ee(r,S,T=>{if(T==ut.FOCUS_EVENT){const J=Date.now();a().revalidateOnFocus&&J>p&&C()&&(p=J+a().focusThrottleInterval,f())}else if(T==ut.RECONNECT_EVENT)a().revalidateOnReconnect&&C()&&f();else if(T==ut.MUTATE_EVENT)return B()});return V.current=!1,q.current=r,A.current=!0,H({_k:O}),_t&&(u(P)||$?f():Xt(f)),()=>{V.current=!0,R()}},[r]),at(()=>{let f;function p(){const R=L(d)?d(P):d;R&&f!==-1&&(f=setTimeout(h,R))}function h(){!F().error&&(D||a().isVisible())&&(m||a().isOnline())?B(lt).then(p):p()}return p(),()=>{f&&(clearTimeout(f),f=-1)}},[d,D,m,r]),w.useDebugValue(ot),i&&u(P)&&r)throw!bt&&$?new Error("Fallback data is required when using suspense in SSR."):(U.current=n,j.current=e,V.current=!1,u(st)?B(lt):st);return{mutate:jt,get data(){return k.data=!0,ot},get error(){return k.error=!0,st},get isValidating(){return k.isValidating=!0,Pt},get isLoading(){return k.isLoading=!0,qt}}};var Te=de(he);function kt(t){return new Promise((n,e)=>{setTimeout(()=>{n()},t)})}const we=async(t,n=0)=>{n&&await kt(n);try{const e=await Vt.get(t,{headers:{"Content-Type":"application/json"},responseType:"json"});return e.status===200?e.data:Promise.reject(e)}catch(e){throw console.error("App fetcher GET error:",e),e}},_e=async(t,n,e=0)=>{e&&await kt(e);try{const s=await Vt.get(t,{headers:{"Content-Type":"application/json"},responseType:"json",signal:n.signal});return s.status===200?s.data:Promise.reject(s)}catch(s){throw s.code!=="ERR_CANCELED"&&console.error("App fetcher GET error:",s),s}};export{we as a,_e as h,Te as u,me as w};
